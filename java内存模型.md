#JAVA内存模型规范：
- 规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值
- 如何以及何时同步的访问共享变量

![](https://upload-images.jianshu.io/upload_images/7220971-b9a4608c0d180f70.png?imageMogr2/auto-orient/)

<pre>
Heap(堆)：java里的堆是一个运行时的数据区，堆是由垃圾回收来负责的，
         堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，
         因为他是在运行时动态分配内存的，java的垃圾回收器会定时收走不用的数据，
         缺点是由于要在运行时动态分配，所有存取速度可能会慢一些
Stack(栈)：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的，
          缺点是存在栈中的数据的大小与生存期必须是确定的，缺乏一些灵活性
          栈中主要存放一些基本类型的变量，比如int，short，long，byte，double，float，boolean，char，对象句柄，

java内存模型要求调用栈和本地内存变量存放在线程栈（Thread Stack）上，对象存放在堆上。
一个本地变量可能存放一个对象的引用，这时引用变量存放在本地栈上，但是对象本身存放在堆上
成员变量跟随着对象存放在堆上，而不管是原始类型还是引用类型，静态成员变量跟随着类的定义一起存在在堆上

存在堆上的对象，可以被持有这个对象的引用的线程访问
如果两个线程同时访问同一个对象的私有变量，这时他们获得的是这个对象的私有拷贝
</pre>

#计算机硬件架构：

![](https://upload-images.jianshu.io/upload_images/7220971-d537fdbba15fa90a.png?imageMogr2/auto-orient/)

<pre>
CPU：一个计算机一般有多个CPU，一个CPU还会有多核
CPU Registers（寄存器）：每个CPU都包含一系列的寄存器，他们是CPU内存的基础，CPU在寄存器上执行的速度远大于在主存上执行的速度。
CPU Cache（高速缓存）：由于计算机的存储设备与处理器的处理设备有着几个数量级的差距，
                    所以现代计算机都会加入一层读写速度与处理器处理速度接近想通的高级缓存来作为内存与处理器之间的缓冲，
                    将运算使用到的数据复制到缓存中，让运算能够快速的执行，当运算结束后，再从缓存同步到内存之中，这样，CPU就不需要等待缓慢的内存读写了
主（内）存：一个计算机包含一个主存，所有的CPU都可以访问主存，主存比缓存容量大的多

运作原理：通常情况下，当一个CPU要读取主存的时候，他会将主存中的数据读取到CPU缓存中，甚至将缓存中的内容读到内部寄存器里面，然后再寄存器执行操作，
当运行结束后，会将寄存器中的值刷新回缓存中，并在某个时间点刷新回主存
</pre>

#内存模型与硬件架构之间的关联：

![](https://upload-images.jianshu.io/upload_images/7220971-d101210475dfd689.png?imageMogr2/auto-orient/)

<pre>
硬件架构没有区分线程栈和堆，对于硬件而言所有线程栈和堆都分布在主内存里面，部分可能会出现在CPU缓存中和CPU内部的寄存器里面
</pre>

#线程和主内存的抽象关系

![](https://upload-images.jianshu.io/upload_images/7220971-9e6e471800d7db9c.png?imageMogr2/auto-orient/)

<pre>
每个线程之间共享变量都存放在主内存里面，每个线程都有一个私有的本地内存
本地内存是java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区。寄存器，以及其他硬件的优化）
本地内存中存储了以读或者写共享变量的拷贝的一个副本

从一个更低的层次来说，线程本地内存，他是cpu缓存，寄存器的一个抽象描述，而JVM的静态内存存储模型，
他只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存

如果线程A和线程B要通信，必须经历两个过程：
1、A将本地内存变量刷新到主内存
2、B从主内存中读取变量
</pre>