# 不可变对象

## 不可变对象需要满足的条件

- 对象创建以后其状态就不能修改
- 对象所有域都是final类型
- 对象是正确创建的（在对象创建期间，this引用没有逸出）

## 创建不可变对象的方式（参考String类型）

- 将类声明成final类型，使其不可以被继承
- 将所有的成员设置成私有的，使其他的类和对象不能直接访问这些成员
- 对变量不提供set方法
- 将所有可变的成员声明为final，这样只能对他们赋值一次
- 通过构造器初始化所有成员，进行深度拷贝
- 在get方法中，不直接返回对象本身，而是克隆对象，返回对象的拷贝

## final关键字：类、方法、变量

- 修饰类：不能被继承（final类中的所有方法都会被隐式的声明为final方法）
- 修饰方法：1、锁定方法不被继承类修改；2、提升效率（private方法被隐式修饰为final方法）
- 修饰变量：基本数据类型变量（初始化之后不能修改）、引用类型变量（初始化之后不能再修改其引用）

## 其他的不可变对象的创建

![](https://upload-images.jianshu.io/upload_images/7220971-bb50553d88c98adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871/format/webp)

- Collections.unmodifiableMap 创建完以后不允许被修改

源码

<pre>
/**
    * 初始化的时候将传进来的map赋值给一个final类型的map，然后将所有会修改的方法直接抛出UnsupportedOperationException异常
     * Returns an unmodifiable view of the specified map.  This method
     * allows modules to provide users with "read-only" access to internal
     * maps.  Query operations on the returned map "read through"
     * to the specified map, and attempts to modify the returned
     * map, whether direct or via its collection views, result in an
     * <tt>UnsupportedOperationException</tt>.<p>
     *
     * The returned map will be serializable if the specified map
     * is serializable.
     *
     * @param <K> the class of the map keys
     * @param <V> the class of the map values
     * @param  m the map for which an unmodifiable view is to be returned.
     * @return an unmodifiable view of the specified map.
     */
    public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
        return new UnmodifiableMap<>(m);
    }

    /**
     * @serial include
     */
    private static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {
        private static final long serialVersionUID = -1034234728574286014L;

        private final Map<? extends K, ? extends V> m;

        UnmodifiableMap(Map<? extends K, ? extends V> m) {
            if (m==null)
                throw new NullPointerException();
            this.m = m;
        }

        public int size()                        {return m.size();}
        public boolean isEmpty()                 {return m.isEmpty();}
        public boolean containsKey(Object key)   {return m.containsKey(key);}
        public boolean containsValue(Object val) {return m.containsValue(val);}
        public V get(Object key)                 {return m.get(key);}

        public V put(K key, V value) {
            throw new UnsupportedOperationException();
        }
        public V remove(Object key) {
            throw new UnsupportedOperationException();
        }
</pre>

示例代码：[ImmutableExample1.java](../src/main/java/com/mmall/concurrency/example/immutable/ImmutableExample1.java)

<pre>
@ThreadSafe
public class ImmutableExample1 {
    private static Map<Integer,Integer> map = Maps.newHashMap();

    static {
        map.put(1,2);
        map = Collections.unmodifiableMap(map);
    }

    public static void main(String[] args) {
        //Exception in thread "main" java.lang.UnsupportedOperationException
        //  at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
        //  at com.gwf.concurrency.example.immutable.ImmutableExample1.main(ImmutableExample1.java:21)
        map.put(1,3);
    }
    
}
</pre>

- Guava:Immutablexxx

源码

<pre>
// ImmutableList
public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) {
        return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11);
    }

// 超过12个元素，则声明为一个数组
    public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {
        Object[] array = new Object[12 + others.length];
        array[0] = e1;
        array[1] = e2;
        array[2] = e3;
        array[3] = e4;
        array[4] = e5;
        array[5] = e6;
        array[6] = e7;
        array[7] = e8;
        array[8] = e9;
        array[9] = e10;
        array[10] = e11;
        array[11] = e12;
        System.arraycopy(others, 0, array, 12, others.length);
        return construct(array);
    }

private static <E> ImmutableList<E> construct(Object... elements) {
        for(int i = 0; i < elements.length; ++i) {
            ObjectArrays.checkElementNotNull(elements[i], i);
        }

        return new RegularImmutableList(elements);
    }
</pre>

示例代码：[ImmutableExample2.java](../src/main/java/com/mmall/concurrency/example/immutable/ImmutableExample2.java)

<pre>
@ThreadSafe
public class ImmutableExample2 {
    private final static List<Integer> list = ImmutableList.of(1,2,3);
    private final static ImmutableSet set = ImmutableSet.copyOf(list);
    // 奇数位参数为key，偶数位参数为value
    private final static ImmutableMap map1 = ImmutableMap.of(1,2,3,5);

    private final static ImmutableMap<Integer,Integer> map2 = ImmutableMap.<Integer,Integer>builder()
            .put(1,2).put(3,4).build();

    public static void main(String[] args) {
        // 执行都会跑出 UnsupportedOperationException异常
        // 但是使用ImmutableXXX声明会直接在编译的时候就告诉你这个方法已经被废弃
        list.add(5);
        set.add(6);
        map1.put(1,2);
        map2.put(3,4);
    }

}
</pre>

# 线程封闭
把对象封装到一个线程里，只有这个线程能看到这个对象

## 实现线程封闭

- Ad-hoc 线程封闭：程序控制实现，最糟糕，忽略
- 堆栈封闭：局部变量，无并发问题
- ThreadLocal 线程封闭：特别好的封闭方法

<pre>
public class RequestHolder {
    private final static ThreadLocal<Long> requestHolder = new ThreadLocal<>();

    /**
     * 添加数据
     * 在filter里将登录用户信息存入ThreadLocal
     * 如果不使用ThreadLocal，我们会需要将request一直透传
     * @param id
     */
    public static void add(Long id){
        // ThreadLocal 内部维护一个map，key为当前线程名，value为当前set的变量
        requestHolder.set(id);
    }

    /**
     * 获取数据
     * @return
     */
    public static Long getId(){
        return requestHolder.get();
    }

    /**
     * 移除变量信息
     * 如果不移除，那么变量不会释放掉，会造成内存泄漏
     * 在接口处理完以后进行处理（interceptor）
     */
    public static void remove(){
        requestHolder.remove();
    }
}
</pre>

# 线程不安全的类与写法

## 1.StringBuilder 线程不安全，StringBuffer线程安全

原因:StringBuffer几乎所有的方法都加了synchronized关键字

示例代码：[StringExample1.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/StringExample1.java)、
[StringExample2.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/StringExample2.java)

<pre>
/**
*  由于StringBuffer 加了 synchronized 所以性能会下降很多
* 所以在堆栈封闭等线程安全的环境下应该首先选用StringBuilder
*/
@Override
    public synchronized StringBuffer append(Object obj) {
        toStringCache = null;
        super.append(String.valueOf(obj));
        return this;
    }
</pre>

## 2.SimpleDateFormat

SimpleDateFormat 在多线程共享使用的时候回抛出转换异常，应该才用堆栈封闭在每次调用方法的时候在方法里创建一个SimpleDateFormat

另一种方式是使用joda-time的DateTimeFormatter(推荐使用)

示例代码：[DateFormatExample1.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/DateFormatExample1.java)、[DateFormatExample2.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/DateFormatExample2.java)、[DateFormatExample3.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/DateFormatExample3.java)

<pre>
&lt;dependency>
   &lt;groupId>joda-time&lt;/groupId>
   &lt;artifactId>joda-time&lt;/artifactId>
   &lt;version>2.9&lt;/version>
&lt;/dependency>

private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyyMMdd");

DateTime.parse("20180320",dateTimeFormatter).toDate();
</pre>

## 3.ArrayList,HashMap,HashSet等Collections

示例代码：[ArrayListExample.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/ArrayListExample.java)

示例代码：[HashMapExample.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/HashMapExample.java)

示例代码：[HashSetExample.java](../src/main/java/com/mmall/concurrency/example/commonUnsafe/HashSetExample.java)

## 4.先检查再执行

先判断a对象是否满足条件，再处理a对象是线程不安全的。假如两个线程都访问了if判断并且都通过了，分别去处理就会触发线程不安全的问题。前一个判断和后一个处理整个过程是非原子性的。

<pre>
// 非原子性
if(condition(a)){
  handle(a);
}
</pre>

# 线程安全-同步容器

## 1.同一接口，不同实现的线程安全类

![](https://upload-images.jianshu.io/upload_images/7220971-f812bdca34761654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

### （1）ArrayList的线程安全类：Vector,Stack
Vector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用synchronized修饰过的方法。 

Stack它的方法也是使用synchronized修饰了，继承了Vector，实际上就是栈 
使用举例（Vector）：

<pre>
//定义
private static List<Integer> list = new Vector<>();
//多线程调用方法
private static void update(int i) {
   list.add(i);
}
</pre>

源码分析：使用了synchronized修饰

<pre>
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
</pre>

但是Vector也不是完全的线程安全的，比如： 
错误[1]：删除与获取并发操作

示例代码：[VectorExample.java](../src/main/java/com/mmall/concurrency/example/syncContainer/VectorExample.java)

运行结果：报错java.lang.ArrayIndexOutOfBoundsException: Array index out of range 
原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。

错误[2]：使用foreach\iterator遍历Vector的时候进行增删操作

示例代码：[VectorExample3.java](../src/main/java/com/mmall/concurrency/example/syncContainer/VectorExample3.java)

解决办法：在使用iteratir进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器

### （2）HashMap的线程安全类：HashTable

使用举例:

<pre>
//定义
private static Map<Integer, Integer> map = new Hashtable<>();
//多线程调用方法
private static void update(int i) {
    map.put(i, i);
}
</pre>

源码分析：

保证安全性：使用了synchronized修饰

不允许空值（在代码中特殊做了判断）

HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。

Entry对象唯一表示一个键值对，有四个属性： 

- K key 键对象 
- V value 值对象 
- int hash 键对象的hash值 
- Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部

<pre>
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) && entry.key.equals(key)) {
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }

    addEntry(hash, key, value, index);
    return null;
}
</pre>

### （3）Collections类中的相关同步方法

Collections类中提供了一系列的线程安全方法用于处理ArrayList等线程不安全的Collection类 

![](https://img-blog.csdn.net/20180413151918577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

使用方法：

<pre>
//定义
private static List<Integer> list = Collections.synchronizedList(Lists.newArrayList());
//多线程调用方法
private static void update(int i) {
    list.add(i);
}
</pre>

源码分析： 

内部操作的方法使用了synchronized修饰符

<pre>
static class SynchronizedList<E>
        extends SynchronizedCollection<E>
        implements List<E> {
        ...
        public E get(int index) {
            synchronized (mutex) {return list.get(index);}
        }
        public E set(int index, E element) {
            synchronized (mutex) {return list.set(index, element);}
        }
        public void add(int index, E element) {
            synchronized (mutex) {list.add(index, element);}
        }
        public E remove(int index) {
            synchronized (mutex) {return list.remove(index);}
        }
        ...
 }
</pre>