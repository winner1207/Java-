# 示例代码

- 线程安全：[CountExample2.java](../src/main/java/com/mmall/concurrency/example/count/CountExample2.java)


# 定义
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类都能表现出正确行为，那么就称这个类是线程安全的

![](https://upload-images.jianshu.io/upload_images/7220971-d72db30c63813f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/896/format/webp)

# 原子性-Atomic包

![](https://upload-images.jianshu.io/upload_images/7220971-411a2d780792834f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592/format/webp)

## 1.AtomicXXX:CAS 、Unsafe.compareAndSwapInt

示例代码：[AtomicExample1.java](../src/main/java/com/mmall/concurrency/example/atomic/AtomicExample1.java)

看一下AtomicInteger.getAndIncrement的源码

<pre>
/**
 * Atomically increments by one the current value.
 *
 * @return the previous value
 */
public final int getAndIncrement() {
     // 主要是调用了unsafe的方法 
     //     private static final Unsafe unsafe = Unsafe.getUnsafe();
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

/**
  *  获取底层当前的值并且+1
  * @param var1 需要操作的AtomicInteger 对象
  * @param var2 当前的值 
  * @param var4 要增加的值
*/
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        // 获取底层的该对象当前的值
        var5 = this.getIntVolatile(var1, var2);
        // 获取完底层的值和自增操作之间，可能系统的值已经又被其他线程改变了
        //如果又被改变了，则重新计算系统底层的值，并重新执行本地方法
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); 

    return var5;
}

/**
  * 本地的CAS方法核心
  * @param var1 需要操作的AtomicInteger 对象
  * @param var2 当前本地变量中的的值 
  * @param var4 当前系统从底层传来的值
  * @param var5 要更新后的值
  * @Return 如果当前本地变量的值（var2）与底层的值(var4)不等，则返回false，否则更新为var5的值并返回True
*/
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
</pre>

## 2.AtomicLong、LongAdder

示例代码：[AtomicExample2.java](../src/main/java/com/mmall/concurrency/example/atomic/AtomicExample2.java)、[AtomicExample3.java](../src/main/java/com/mmall/concurrency/example/atomic/AtomicExample3.java)

我们看到AtomicInteger在执行CAS操作的时候，是用死循环的方式，如果竞争非常激烈，那么失败量就会很高，性能会受到影响

再看一下1.8以后的LongAdder

<pre>
public void add(long x) {
        Cell[] as; long b, v; int m; Cell a;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[getProbe() & m]) == null ||
                !(uncontended = a.cas(v = a.value, v + x)))
                longAccumulate(x, null, uncontended);
        }
    }
</pre>

补充知识点，jvm对long，double这些64位的变量拆成两个32位的操作

* LongAdder的设计思想：核心是将热点数据分离，将内部数据value分成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行技术，而最终计数结果为这个数组的求和累加，
其中热点数据value会被分离成多个热点单元的数据cell，每个cell独自维护内部的值，当前value的实际值由所有的cell累积合成，从而使热点进行了有效的分离，提高了并行度
* LongAdder 在低并发的时候通过直接操作base，可以很好的保证和Atomic的性能基本一致，在高并发的场景，通过热点分区来提高并行度

* 缺点：在统计的时候如果有并发更新，可能会导致结果有些误差

## 3.AtomicReference、AtomicReferenceFieldUpdater

示例代码：[AtomicExample4.java](../src/main/java/com/mmall/concurrency/example/atomic/AtomicExample4.java)、[AtomicExample5.java](../src/main/java/com/mmall/concurrency/example/atomic/AtomicExample5.java)

AtomicReference: 用法同AtomicInteger一样，但是可以放各种对象

<pre>
@Slf4j
@ThreadSafe
public class AtomicExample4 {

    public static AtomicReference<Integer> count = new AtomicReference<>(0);

    public static void main(String[] args) throws InterruptedException {
        // 2
        count.compareAndSet(0,2);  
        // no
        count.compareAndSet(0,1);
        // no
        count.compareAndSet(1,3);
        // 4
        count.compareAndSet(2,4);
        // no
        count.compareAndSet(3,5);
        log.info("count:{}",count.get());
    }

}
</pre>

AtomicReferenceFieldUpdater

<pre>
@Slf4j
@ThreadSafe
public class AtomicExample5 {

    @Getter
    private volatile int count = 100;

    /**
     * AtomicIntegerFieldUpdater 核心是原子性的去更新某一个类的实例的指定的某一个字段
     * 构造函数第一个参数为类定义，第二个参数为指定字段的属性名，必须是volatile修饰并且非static的字段
     */
    private static AtomicIntegerFieldUpdater<AtomicExample5> updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,"count");


    public static void main(String[] args) throws InterruptedException {
        AtomicExample5 example5 = new AtomicExample5();

        // 第一次 count=100 -> count->120 返回True
        if(updater.compareAndSet(example5,100,120)){
            log.info("update success 1:{}",example5.getCount());
        }

        // count=120 -> 返回False
        if(updater.compareAndSet(example5,100,120)){
            log.info("update success 2:{}",example5.getCount());
        }else {
            log.info("update field:{}",example5.getCount());

        }
    }

}
</pre>

## 5.AtomicStampReference:CAS的ABA问题
ABA问题：在CAS操作的时候，其他线程将变量的值A改成了B由改成了A，本线程使用期望值A与当前变量进行比较的时候，发现A变量没有变，于是CAS就将A值进行了交换操作，这个时候实际上A值已经被其他线程改变过，这与设计思想是不符合的

解决思路：每次变量更新的时候，把变量的版本号加一，这样只要变量被某一个线程修改过，该变量版本号就会发生递增操作，从而解决了ABA变化

<pre>
/**
     * Atomically sets the value of both the reference and stamp
     * to the given update values if the
     * current reference is {@code ==} to the expected reference
     * and the current stamp is equal to the expected stamp.
     *
     * @param expectedReference the expected value of the reference
     * @param newReference the new value for the reference
     * @param expectedStamp the expected value of the stamp(上面提到的版本号)
     * @param newStamp the new value for the stamp
     * @return {@code true} if successful
     */
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
</pre>


## 6.AtomicLongArray
可以指定更新一个数组指定索引位置的值

<pre>
/**
     * Atomically sets the element at position {@code i} to the given value
     * and returns the old value.
     *
     * @param i the index
     * @param newValue the new value
     * @return the previous value
     */
    public final long getAndSet(int i, long newValue) {
        return unsafe.getAndSetLong(array, checkedByteOffset(i), newValue);
    }
...
...
/**
     * Atomically sets the element at position {@code i} to the given
     * updated value if the current value {@code ==} the expected value.
     *
     * @param i the index
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(int i, long expect, long update) {
        return compareAndSetRaw(checkedByteOffset(i), expect, update);
    }
</pre>

## AtomicBoolean(平时用的比较多)
compareAndSet方法也值得注意，可以达到同一时间只有一个线程执行这段代码

<pre>
/**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(boolean expect, boolean update) {
        int e = expect ? 1 : 0;
        int u = update ? 1 : 0;
        return unsafe.compareAndSwapInt(this, valueOffset, e, u);
    }
</pre>

# 原子性-锁
* synchronized：依赖JVM （主要依赖JVM实现锁，因此在这个关键字作用对象的作用范围内，都是同一时刻只能有一个线程进行操作的）
* Lock：依赖特殊的CPU指令，代码实现，ReentrantLock

## 修饰的内容分类

![](https://upload-images.jianshu.io/upload_images/7220971-0dbbdf6f1a084100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/798/format/webp)

